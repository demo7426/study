/*************************************************
Copyright (C), 2009-2012    , Level Chip Co., Ltd.
文件名:	Device.c
作  者:	钱锐      版本: V0.1.0     新建日期: 2024.02.19
描  述: 封装一些简易处理
备  注:
修改记录:

  1.  日期: 2024.02.19
	  作者: 钱锐
	  内容:
		  1) 此为模板第一个版本;
	  版本:V0.1.0

*************************************************/

#include <ntifs.h>
#include <wdm.h>

#include "Device.h"
#include "Dispatch.h"

#ifdef __cplusplus
extern "C"
{
#endif  __cplusplus
	NTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName(IN PUNICODE_STRING ObjectName,
		IN ULONG Attributes,
		IN PACCESS_STATE AccessState OPTIONAL,
		IN ACCESS_MASK DesiredAccess OPTIONAL,
		IN POBJECT_TYPE ObjectType,
		IN KPROCESSOR_MODE AccessMode,
		IN OUT PVOID ParseContext OPTIONAL,
		OUT PVOID* Object);

	extern POBJECT_TYPE* IoDeviceObjectType;
	extern POBJECT_TYPE* IoDriverObjectType;
#ifdef __cplusplus
}
#endif __cplusplus

PDEVICE_OBJECT GetDeviceObjectByName(IN PCWSTR _pDevicePath)
{
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	UNICODE_STRING tDeviceName;
	PFILE_OBJECT ptFileObj = NULL;
	PDEVICE_OBJECT ptDevObj = NULL;

	RtlInitUnicodeString(&tDeviceName, _pDevicePath);

	lNTStatus = IoGetDeviceObjectPointer(&tDeviceName, FILE_ANY_ACCESS, &ptFileObj, &ptDevObj);		//函数只会增加对 ptFileObj 的引用计数
	if (!NT_SUCCESS(lNTStatus) || !ptFileObj || !ptDevObj)
	{
		KdPrint(("获取设备对象指针出错, 0x%x\n", lNTStatus));
		return NULL;
	}

	ObDereferenceObject(ptFileObj);
	ptFileObj = NULL;

	ObReferenceObject(ptDevObj);

	return ptDevObj;
}

PDRIVER_OBJECT GetDriverObjectByName(IN PCWSTR _pDriverPath)
{
	UNICODE_STRING tDriverName;
	PDRIVER_OBJECT ptDriverObj = NULL;
	NTSTATUS lNTStatus = STATUS_SUCCESS;

	RtlInitUnicodeString(&tDriverName, _pDriverPath);

	lNTStatus = ObReferenceObjectByName(&tDriverName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, FILE_ANY_ACCESS, *IoDriverObjectType, KernelMode, NULL, &ptDriverObj);
	if (!NT_SUCCESS(lNTStatus))
	{
		KdPrint(("ObReferenceObjectByName is err.\n"));
		KdPrint(("0x%x\n", lNTStatus));
		return NULL;
	}

	return ptDriverObj;
}

PDEVICE_OBJECT CreateNewDeviceAndAttachedToPDO(IN PDRIVER_OBJECT _pDriverObject, IN PDEVICE_OBJECT _pPDO)
{
	if (!_pDriverObject || !_pPDO)
	{
		KdPrint(("CreateNewDeviceAndAttachedToPDO input param is err.\n"));
		return NULL;
	}

	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PDEVICE_OBJECT ptFDO = NULL;
	PDEVICEEXTENSION ptDevExtension = NULL;

	lNTStatus = IoCreateDevice(_pDriverObject, sizeof(DEVICEEXTENSION), NULL, FILE_DEVICE_UNKNOWN, FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &ptFDO);
	if (!NT_SUCCESS(lNTStatus))
	{
		KdPrint(("IoCreateDevice is err.\n"));
		return NULL;
	}
	
	ptDevExtension = ptFDO->DeviceExtension; 

	RtlFillMemory(ptDevExtension, sizeof(*ptDevExtension), 0);
	RtlCopyMemory(ptDevExtension->IORemoveLock_Tag, "1gaT", strlen("1gaT"));							//一般使用4个方向的Tag1、Tag2、Tag3...Tagn字符

	IoInitializeRemoveLock(&ptDevExtension->IORemoveLock, '1gaT', 0, 0);								//一般使用4个方向的Tag1、Tag2、Tag3...Tagn字符

	ptDevExtension->pNextDevice = IoAttachDeviceToDeviceStack(ptFDO, _pPDO);
	if (ptDevExtension->pNextDevice == NULL)
	{
		KdPrint(("IoAttachDeviceToDeviceStack is err\n"));
		return NULL;
	}

	ptFDO->Characteristics = ptDevExtension->pNextDevice->Characteristics;
	ptFDO->DeviceType = ptDevExtension->pNextDevice->DeviceType;
	ptFDO->Flags = ptDevExtension->pNextDevice->Flags;
	ptFDO->Flags &= ~DO_DEVICE_INITIALIZING;

	for (size_t i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
	{
		_pDriverObject->MajorFunction[i] = Dispatch_Default;											//过滤驱动必须实现所有的派遣函数
	}
	_pDriverObject->MajorFunction[IRP_MJ_WRITE] = Dispatch_Write;
	_pDriverObject->MajorFunction[IRP_MJ_PNP] = Dispatch_Pnp;
	_pDriverObject->MajorFunction[IRP_MJ_POWER] = Dispatch_Power;

	return ptDevExtension->pNextDevice;
}

//关闭写保护
KIRQL WPOff(VOID)
{
	KIRQL tKIrqL = KeRaiseIrqlToDpcLevel();		//硬件优先级提高到 IRQL = DISPATCH_LEVEL，从而屏蔽当前处理器上等效或更低 IRQL 的中断。
	ULONG_PTR ulCr0 = __readcr0();

	//写保护寄存器置零
#ifdef _X86_
	ulCr0 &= ~0x00010000;
#else
	ulCr0 &= ~0x0000000000010000;
#endif // _X86_

	_disable();									//禁用中断
	__writecr0(ulCr0);

	return tKIrqL;
}

//开启写保护
VOID WPOn(KIRQL _KIrqL)
{
	KIRQL tKIrqL = KeRaiseIrqlToDpcLevel();
	ULONG_PTR ulCr0 = __readcr0();

	ulCr0 |= 0x10000;							//写保护寄存器置1

	_enable();									//开启中断
	__writecr0(ulCr0);

	KeLowerIrql(_KIrqL);
}
