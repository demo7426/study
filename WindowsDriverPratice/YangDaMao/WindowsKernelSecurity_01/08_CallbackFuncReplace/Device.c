/*************************************************
Copyright (C), 2009-2012    , Level Chip Co., Ltd.
文件名:	Device.c
作  者:	钱锐      版本: V0.1.0     新建日期: 2024.02.19
描  述: 封装一些简易处理
备  注:
修改记录:

  1.  日期: 2024.02.19
	  作者: 钱锐
	  内容:
		  1) 此为模板第一个版本;
	  版本:V0.1.0

*************************************************/

#include <ntifs.h>
#include <wdm.h>

#include "Device.h"
#include "Dispatch.h"

#ifdef __cplusplus
extern "C"
{
#endif  __cplusplus
	NTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName(IN PUNICODE_STRING ObjectName,
		IN ULONG Attributes,
		IN PACCESS_STATE AccessState OPTIONAL,
		IN ACCESS_MASK DesiredAccess OPTIONAL,
		IN POBJECT_TYPE ObjectType,
		IN KPROCESSOR_MODE AccessMode,
		IN OUT PVOID ParseContext OPTIONAL,
		OUT PVOID* Object);

	extern POBJECT_TYPE* IoDeviceObjectType;
	extern POBJECT_TYPE* IoDriverObjectType;
#ifdef __cplusplus
}
#endif __cplusplus

PDEVICE_OBJECT GetDeviceObjectByName(IN PCWSTR _pDevicePath)
{
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	UNICODE_STRING tDeviceName;
	PFILE_OBJECT ptFileObj = NULL;
	PDEVICE_OBJECT ptDevObj = NULL;

	RtlInitUnicodeString(&tDeviceName, _pDevicePath);

	lNTStatus = IoGetDeviceObjectPointer(&tDeviceName, FILE_ANY_ACCESS, &ptFileObj, &ptDevObj);		//函数只会增加对 ptFileObj 的引用计数
	if (!NT_SUCCESS(lNTStatus) || !ptFileObj || !ptDevObj)
	{
		KdPrint(("获取设备对象指针出错, 0x%x\n", lNTStatus));
		return NULL;
	}

	ObDereferenceObject(ptFileObj);
	ptFileObj = NULL;

	ObReferenceObject(ptDevObj);

	return ptDevObj;
}

PDRIVER_OBJECT GetDriverObjectByName(IN PCWSTR _pDriverPath)
{
	UNICODE_STRING tDriverName;
	PDRIVER_OBJECT ptDriverObj = NULL;
	NTSTATUS lNTStatus = STATUS_SUCCESS;

	RtlInitUnicodeString(&tDriverName, _pDriverPath);

	lNTStatus = ObReferenceObjectByName(&tDriverName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, FILE_ANY_ACCESS, *IoDriverObjectType, KernelMode, NULL, &ptDriverObj);
	if (!NT_SUCCESS(lNTStatus))
	{
		KdPrint(("ObReferenceObjectByName is err.\n"));
		KdPrint(("0x%x\n", lNTStatus));
		return NULL;
	}

	return ptDriverObj;
}

PDEVICE_OBJECT CreateNewDeviceAndAttachedToPDO(IN PDRIVER_OBJECT _pDriverObject, IN PDEVICE_OBJECT _pPDO)
{
	if (!_pDriverObject || !_pPDO)
	{
		KdPrint(("CreateNewDeviceAndAttachedToPDO input param is err.\n"));
		return NULL;
	}

	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PDEVICE_OBJECT ptFDO = NULL;
	PDEVICEEXTENSION ptDevExtension = NULL;

	lNTStatus = IoCreateDevice(_pDriverObject, sizeof(DEVICEEXTENSION), NULL, FILE_DEVICE_UNKNOWN, FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &ptFDO);
	if (!NT_SUCCESS(lNTStatus))
	{
		KdPrint(("IoCreateDevice is err.\n"));
		return NULL;
	}
	
	ptDevExtension = ptFDO->DeviceExtension; 

	RtlFillMemory(ptDevExtension, sizeof(*ptDevExtension), 0);
	RtlCopyMemory(ptDevExtension->IORemoveLock_Tag, "1gaT", strlen("1gaT"));							//一般使用4个方向的Tag1、Tag2、Tag3...Tagn字符

	IoInitializeRemoveLock(&ptDevExtension->IORemoveLock, '1gaT', 0, 0);								//一般使用4个方向的Tag1、Tag2、Tag3...Tagn字符

	ptDevExtension->pNextDevice = IoAttachDeviceToDeviceStack(ptFDO, _pPDO);
	if (ptDevExtension->pNextDevice == NULL)
	{
		KdPrint(("IoAttachDeviceToDeviceStack is err\n"));
		return NULL;
	}

	ptFDO->Characteristics = ptDevExtension->pNextDevice->Characteristics;
	ptFDO->DeviceType = ptDevExtension->pNextDevice->DeviceType;
	ptFDO->Flags = ptDevExtension->pNextDevice->Flags;
	ptFDO->Flags &= ~DO_DEVICE_INITIALIZING;

	for (size_t i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
	{
		_pDriverObject->MajorFunction[i] = Dispatch_Default;											//过滤驱动必须实现所有的派遣函数
	}
	_pDriverObject->MajorFunction[IRP_MJ_WRITE] = Dispatch_Write;
	_pDriverObject->MajorFunction[IRP_MJ_PNP] = Dispatch_Pnp;
	_pDriverObject->MajorFunction[IRP_MJ_POWER] = Dispatch_Power;

	return ptDevExtension->pNextDevice;
}

NTSTATUS GetKeyBoardCallbackFunc(PWCHAR _pClassDriverPath, PWCHAR _pMinDriverPath, PLIST_ENTRY _pResCallbackFunc_List_Entry)
{
	if (!_pClassDriverPath || !_pMinDriverPath || !_pResCallbackFunc_List_Entry)
	{
		KdPrint(("GetKeyBoardCallbackFunc input param is err.\n"));
		return STATUS_INVALID_PARAMETER;
	}

	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PDRIVER_OBJECT ptFilterDrvObj = NULL;				//功能设备对象的过滤驱动对象
	PDRIVER_OBJECT ptDrvObj = NULL;						//功能驱动对象
	
	PDEVICE_OBJECT ptFilterDevObj = NULL;				//功能设备对象的过滤设备对象
	PDEVICE_OBJECT ptDevObj = NULL;						//功能设备对象
	
	ULONG64 ullFilterDrvStart = 0;						//功能设备对象的过滤驱动对象的起始地址
	ULONG64 ullFilterDrvEnd = 0;						//功能设备对象的过滤驱动对象的结束地址

	KeyBoardCallbackFunc_Type pfKeyBoardCallbackFunc_StartAddr = NULL;

	ptFilterDrvObj = GetDriverObjectByName(_pClassDriverPath);
	if (!ptFilterDrvObj)
	{
		KdPrint(("GetKeyBoardCallbackFunc GetDriverObjectByName is err.\n"));
		return STATUS_INVALID_VARIANT;
	}

	ptFilterDevObj = ptFilterDrvObj->DeviceObject;		//TODO:只处理了一个设备对象，如果有多个键盘接入主机的情况，需要将 NextDevice 也一并处理
	
	ullFilterDrvStart = (ULONG64)ptFilterDrvObj->DriverStart;
	ullFilterDrvEnd = (ULONG64)ptFilterDrvObj->DriverStart + ptFilterDrvObj->DriverSize;

	ptDrvObj = GetDriverObjectByName(_pMinDriverPath);
	if (!ptDrvObj)
	{
		ObDereferenceObject(ptFilterDrvObj);
		ptFilterDrvObj = NULL;

		KdPrint(("GetKeyBoardCallbackFunc GetDriverObjectByName is err.\n"));
		return STATUS_INVALID_VARIANT;
	}

	ptDevObj = ptDrvObj->DeviceObject;		

	static ULONG32 ulFreq = 0;
	while (ptDevObj)									//遍历同级所有的功能设备对象，查找出其所有的设备对象回调函数的起始地址
	{
		KdPrint(("ptFilterDevObj = 0x%p, pvFilterDrvStart = 0x%llu, ullFilterDrvEnd = 0x%llu, ptDevObj = 0x%p\n", 
			ptFilterDevObj, ullFilterDrvStart, ullFilterDrvEnd, ptDevObj));

		//获取 ptDevObj 其设备扩展内部保存的 ptFilterDevObj 回调函数的起始地址
		lNTStatus = FindCallbackFunc_StartAddr(ptFilterDevObj, ullFilterDrvStart, ullFilterDrvEnd, ptDevObj, &pfKeyBoardCallbackFunc_StartAddr);
		if (NT_SUCCESS(lNTStatus))
		{
			PDEVICE_CALLBACKFUNC_INFO ptDev_Callback_Info = ExAllocatePool(PagedPool, sizeof(DEVICE_CALLBACKFUNC_INFO));
			if (!ptDev_Callback_Info)
			{
				//TODO:若失败则需要将之前成功分配的资源释放
				ObDereferenceObject(ptFilterDrvObj);
				ObDereferenceObject(ptDrvObj);
				ptFilterDrvObj = NULL;
				ptDrvObj = NULL;

				KdPrint(("ulFreq = %u\n", ulFreq));
				KdPrint(("GetKeyBoardCallbackFunc ExAllocatePool is err.\n"));
				return STATUS_INSUFFICIENT_RESOURCES;
			}

			//保存所有的回调函数的起始地址到链表中
			ptDev_Callback_Info->CallbackFuncStartAddr = pfKeyBoardCallbackFunc_StartAddr;
			InsertHeadList(_pResCallbackFunc_List_Entry, &ptDev_Callback_Info->List_Entry);

			ulFreq++;
		}

		ptDevObj = ptDevObj->NextDevice;
	}

	KdPrint(("ulFreq = %u\n", ulFreq));

	ObDereferenceObject(ptFilterDrvObj);
	ObDereferenceObject(ptDrvObj);
	ptFilterDrvObj = NULL;
	ptDrvObj = NULL;

	return lNTStatus;
}

NTSTATUS FindCallbackFunc_StartAddr(PDEVICE_OBJECT _pSrcDevObj, ULONG64 _SrcDrvStart, ULONG64 _SrcDrvEnd, PDEVICE_OBJECT _pFindedDevObj, KeyBoardCallbackFunc_Type* _ppCallFuncStartAddr)
{
#if 0
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PVOID pvDevExtension = _pFindedDevObj->DeviceExtension;
	PCHAR pchCurAddr = NULL;

	for (size_t i = 0; i < 0x500; i += 8)
	{
		pchCurAddr = (PCHAR)pvDevExtension + i;

		KdPrint(("pchCurAddr = 0x%p, _pSrcDevObj = 0x%p, *(PDEVICE_OBJECT*)pchCurAddr = 0x%p\n", pchCurAddr, _pSrcDevObj, *(PDEVICE_OBJECT*)pchCurAddr));

		if (*(PDEVICE_OBJECT*)pchCurAddr == _pSrcDevObj)		//找到扩展内部对应的 _pSrcDevObj 设备对象
		{
			ULONG64 ullCallbackFunc = *(ULONG64*)(pchCurAddr + sizeof(PVOID));	//回调函数指针
			
			if (ullCallbackFunc >= (ULONG64)_pSrcDrvStart && ullCallbackFunc <= (ULONG64)_pSrcDrvEnd)
			{
				KdPrint(("pchCallbackFunc = 0x%llx\n", ullCallbackFunc));

				*_ppCallFuncStartAddr = (KeyBoardCallbackFunc_Type)(pchCurAddr + sizeof(PVOID));
				return STATUS_SUCCESS;
			}
		}
	}

	return STATUS_FAIL_CHECK;
#else
	PVOID pDex = _pFindedDevObj->DeviceExtension;
	char* p = 0;
	for (ULONG i = 0; i < 0x500; i += 8)
	{
		p = (char*)pDex + i;
		if (*(PDEVICE_OBJECT*)p == _pSrcDevObj)
		{
			char* p1 = p + 8;//回调函数的函数指针
			ULONGLONG u = *((ULONGLONG*)p1);

			if (u >= _SrcDrvStart && u < _SrcDrvEnd)
			{
				*_ppCallFuncStartAddr = (KeyBoardCallbackFunc_Type)p1;
				return STATUS_SUCCESS;
			}
		}
	}
	return STATUS_FAIL_CHECK;

#endif
}

//关闭写保护
KIRQL WPOff(VOID)
{
	KIRQL tKIrqL = KeRaiseIrqlToDpcLevel();		//硬件优先级提高到 IRQL = DISPATCH_LEVEL，从而屏蔽当前处理器上等效或更低 IRQL 的中断。
	ULONG_PTR ulCr0 = __readcr0();

	//写保护寄存器置零
#ifdef _X86_
	ulCr0 &= ~0x00010000;
#else
	ulCr0 &= ~0x0000000000010000;
#endif // _X86_

	_disable();									//禁用中断
	__writecr0(ulCr0);

	return tKIrqL;
}

//开启写保护
VOID WPOn(KIRQL _KIrqL)
{
	KIRQL tKIrqL = KeRaiseIrqlToDpcLevel();
	ULONG_PTR ulCr0 = __readcr0();

	ulCr0 |= 0x10000;							//写保护寄存器置1

	_enable();									//开启中断
	__writecr0(ulCr0);

	KeLowerIrql(_KIrqL);
}
