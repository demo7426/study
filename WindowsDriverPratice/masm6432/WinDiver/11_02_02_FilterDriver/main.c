/*************************************************
Copyright (C), 2009-2012    , Level Chip Co., Ltd.
文件名:	main.c
作  者:	钱锐      版本: V0.1.0     新建日期: 2024.12.23
描  述: 过滤式驱动程序
备  注: 可以将该驱动程序附加到其它驱动上，起到一个过滤的作用
		使用 09_03_TimeAndIrpTimeoutProcess 和 09_03_UserTest 进行联合测试
修改记录:

  1.  日期: 2024.12.23
	  作者: 钱锐
	  内容:
		  1) 此为模板第一个版本;
	  版本:V0.1.0

*************************************************/

#include <ntddk.h>

typedef struct _DEVICETARGET_INFO
{
	PDEVICE_OBJECT pAttachedDevObj;				//附加的目标设备
}DEVICETARGET_INFO, *PDEVICETARGET_INFO;

NTSTATUS Driver_Create(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp);

NTSTATUS Driver_Read(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp);

NTSTATUS Driver_Close(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp);

VOID DriverUnload(IN PDRIVER_OBJECT DriverObject)
{
	PDEVICETARGET_INFO pDevTarget_Info = (PDEVICETARGET_INFO)DriverObject->DeviceObject->DeviceExtension;

	KdPrint(("驱动卸载成功\n"));

	if (pDevTarget_Info)
		IoDetachDevice(pDevTarget_Info->pAttachedDevObj);

	if (DriverObject->DeviceObject)
	{
		IoDeleteDevice(DriverObject->DeviceObject);
	}
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PFILE_OBJECT ptAttachedFileObj = NULL;
	PDEVICE_OBJECT ptAttachedDeviceObj = NULL;
	PDEVICE_OBJECT ptDeviceObj = NULL;
	UNICODE_STRING tpAttachedDevObjDeviceName = RTL_CONSTANT_STRING(L"\\Device\\HelloDDK");				//附加的设备对象名
	PDEVICETARGET_INFO pDevTarget_Info = NULL;

	KdPrint(("驱动加载成功\n"));

	DriverObject->DriverUnload = DriverUnload;

	//创建一个设备对象，其设备对象名称有操作系统自动生成
	lNTStatus = IoCreateDevice(DriverObject, sizeof(DEVICETARGET_INFO), NULL, FILE_DEVICE_UNKNOWN, FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &ptDeviceObj);
	if (!NT_SUCCESS(lNTStatus))
	{
		KdPrint(("创建设备对象失败\n"));
		return lNTStatus;
	}

	DriverObject->MajorFunction[IRP_MJ_CREATE] = Driver_Create;
	DriverObject->MajorFunction[IRP_MJ_READ] = Driver_Read;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = Driver_Close;

	pDevTarget_Info = (PDEVICETARGET_INFO)ptDeviceObj->DeviceExtension;

	lNTStatus = IoGetDeviceObjectPointer(&tpAttachedDevObjDeviceName, FILE_ANY_ACCESS, &ptAttachedFileObj, &ptAttachedDeviceObj);
	if (!NT_SUCCESS(lNTStatus))
	{
		KdPrint(("IoGetDeviceObjectPointer is err\n"));
		return lNTStatus;
	}

	pDevTarget_Info->pAttachedDevObj = IoAttachDeviceToDeviceStack(ptDeviceObj, ptAttachedDeviceObj);		//附加设备对象到其它设备对象上
	if (pDevTarget_Info->pAttachedDevObj == NULL)
	{
		KdPrint(("IoAttachDeviceToDeviceStack is err\n"));
		return lNTStatus;
	}

	ptDeviceObj->Characteristics = pDevTarget_Info->pAttachedDevObj->Characteristics;
	ptDeviceObj->DeviceType = pDevTarget_Info->pAttachedDevObj->DeviceType;
	ptDeviceObj->Flags = pDevTarget_Info->pAttachedDevObj->Flags;
	ptDeviceObj->Flags &= ~DO_DEVICE_INITIALIZING;

	ObDereferenceObject(ptAttachedFileObj);

	return lNTStatus;
}

NTSTATUS Driver_Create(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp)
{
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PDEVICETARGET_INFO pDevTarget_Info = (PDEVICETARGET_INFO)DeviceObject->DeviceExtension;

	KdPrint(("FileterDriver Driver_Create is enter.\n"));

	IoSkipCurrentIrpStackLocation(Irp);

	lNTStatus = IoCallDriver(pDevTarget_Info->pAttachedDevObj, Irp);

	KdPrint(("FileterDriver Driver_Create is end.\n"));

	return lNTStatus;
}

NTSTATUS Driver_Read(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp)
{
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PDEVICETARGET_INFO pDevTarget_Info = (PDEVICETARGET_INFO)DeviceObject->DeviceExtension;

	KdPrint(("FileterDriver Driver_Read is enter.\n"));

	IoSkipCurrentIrpStackLocation(Irp);

	lNTStatus = IoCallDriver(pDevTarget_Info->pAttachedDevObj, Irp);

	KdPrint(("FileterDriver Driver_Read is end.\n"));

	return lNTStatus;
}

NTSTATUS Driver_Close(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp)
{
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PDEVICETARGET_INFO pDevTarget_Info = (PDEVICETARGET_INFO)DeviceObject->DeviceExtension;

	KdPrint(("FileterDriver Driver_Close is enter.\n"));

	IoSkipCurrentIrpStackLocation(Irp);

	lNTStatus = IoCallDriver(pDevTarget_Info->pAttachedDevObj, Irp);

	KdPrint(("FileterDriver Driver_Close is end.\n"));

	return lNTStatus;
}
