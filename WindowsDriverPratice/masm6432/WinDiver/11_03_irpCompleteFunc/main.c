/*************************************************
Copyright (C), 2009-2012    , Level Chip Co., Ltd.
文件名:	main.c
作  者:	钱锐      版本: V0.1.0     新建日期: 2024.12.24
描  述: irp完成函数
备  注: 下层驱动处理了Irp之后会回调上层过滤驱动的完成回调函数，上层驱动从而再次取得控制权
		使用 09_03_TimeAndIrpTimeoutProcess 和 09_03_UserTest 进行联合测试
		
		使用 _TwiceIoComplete宏区分是否多次取得驱动的控制权
修改记录:

  1.  日期: 2024.12.24
	  作者: 钱锐
	  内容:
		  1) 此为模板第一个版本;
	  版本:V0.1.0

*************************************************/

#include <ntddk.h>

typedef struct _DEVICETARGET_INFO
{
	PDEVICE_OBJECT pAttachedDevObj;				//附加的目标设备
}DEVICETARGET_INFO, * PDEVICETARGET_INFO;

NTSTATUS Driver_Create(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp);

NTSTATUS Driver_Read(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp);

NTSTATUS Driver_Close(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp);

VOID DriverUnload(IN PDRIVER_OBJECT DriverObject)
{
	PDEVICETARGET_INFO pDevTarget_Info = (PDEVICETARGET_INFO)DriverObject->DeviceObject->DeviceExtension;

	KdPrint(("驱动卸载成功\n"));

	if (pDevTarget_Info)
		IoDetachDevice(pDevTarget_Info->pAttachedDevObj);

	if (DriverObject->DeviceObject)
	{
		IoDeleteDevice(DriverObject->DeviceObject);
	}
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PFILE_OBJECT ptAttachedFileObj = NULL;
	PDEVICE_OBJECT ptAttachedDeviceObj = NULL;
	PDEVICE_OBJECT ptDeviceObj = NULL;
	UNICODE_STRING tpAttachedDevObjDeviceName = RTL_CONSTANT_STRING(L"\\Device\\HelloDDK");				//附加的设备对象名
	PDEVICETARGET_INFO pDevTarget_Info = NULL;

	KdPrint(("驱动加载成功\n"));

	DriverObject->DriverUnload = DriverUnload;

	//创建一个设备对象，其设备对象名称有操作系统自动生成
	lNTStatus = IoCreateDevice(DriverObject, sizeof(DEVICETARGET_INFO), NULL, FILE_DEVICE_UNKNOWN, FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &ptDeviceObj);
	if (!NT_SUCCESS(lNTStatus))
	{
		KdPrint(("创建设备对象失败\n"));
		return lNTStatus;
	}

	DriverObject->MajorFunction[IRP_MJ_CREATE] = Driver_Create;
	DriverObject->MajorFunction[IRP_MJ_READ] = Driver_Read;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = Driver_Close;

	pDevTarget_Info = (PDEVICETARGET_INFO)ptDeviceObj->DeviceExtension;

	lNTStatus = IoGetDeviceObjectPointer(&tpAttachedDevObjDeviceName, FILE_ANY_ACCESS, &ptAttachedFileObj, &ptAttachedDeviceObj);
	if (!NT_SUCCESS(lNTStatus))
	{
		KdPrint(("IoGetDeviceObjectPointer is err\n"));
		return lNTStatus;
	}

	pDevTarget_Info->pAttachedDevObj = IoAttachDeviceToDeviceStack(ptDeviceObj, ptAttachedDeviceObj);		//附加设备对象到其它设备对象上
	if (pDevTarget_Info->pAttachedDevObj == NULL)
	{
		KdPrint(("IoAttachDeviceToDeviceStack is err\n"));
		return lNTStatus;
	}

	ptDeviceObj->Characteristics = pDevTarget_Info->pAttachedDevObj->Characteristics;
	ptDeviceObj->DeviceType = pDevTarget_Info->pAttachedDevObj->DeviceType;
	ptDeviceObj->Flags = pDevTarget_Info->pAttachedDevObj->Flags;
	ptDeviceObj->Flags &= ~DO_DEVICE_INITIALIZING;

	ObDereferenceObject(ptAttachedFileObj);

	return lNTStatus;
}

NTSTATUS Driver_Create(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp)
{
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PDEVICETARGET_INFO pDevTarget_Info = (PDEVICETARGET_INFO)DeviceObject->DeviceExtension;

	KdPrint(("FileterDriver Driver_Create is enter.\n"));

	IoSkipCurrentIrpStackLocation(Irp);

	lNTStatus = IoCallDriver(pDevTarget_Info->pAttachedDevObj, Irp);

	KdPrint(("FileterDriver Driver_Create is end.\n"));

	return lNTStatus;
}

NTSTATUS IoCompletionRoutine(
	_In_ PDEVICE_OBJECT DeviceObject,
	_In_ PIRP Irp,
	_In_reads_opt_(_Inexpressible_("varies")) PVOID Context
)
{
#ifdef _TwiceIoComplete		//多次取得控制权
	PKEVENT ptKEvent = Context;
	KeSetEvent(ptKEvent, IO_NO_INCREMENT, FALSE);
	KdPrint(("FileterDriver IoCompletionRoutine is enter.\n"));

	KdPrint(("FileterDriver IoCompletionRoutine is end.\n"));

	return STATUS_MORE_PROCESSING_REQUIRED;;
#else
	KdPrint(("FileterDriver IoCompletionRoutine is enter.\n"));

	if (Irp->PendingReturned)
	{
		IoMarkIrpPending(Irp);
	}

	KdPrint(("FileterDriver IoCompletionRoutine is end.\n"));

	return STATUS_CONTINUE_COMPLETION;
#endif
}

NTSTATUS Driver_Read(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp)
{
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PDEVICETARGET_INFO pDevTarget_Info = (PDEVICETARGET_INFO)DeviceObject->DeviceExtension;

	KdPrint(("FileterDriver Driver_Read is enter.\n"));

	//IoSkipCurrentIrpStackLocation(Irp);
	IoCopyCurrentIrpStackLocationToNext(Irp);
	
#ifdef _TwiceIoComplete		//多次取得控制权
	KEVENT tKEvent;

	KeInitializeEvent(&tKEvent, NotificationEvent, FALSE);
	IoSetCompletionRoutine((PIRP)Irp, IoCompletionRoutine, &tKEvent, TRUE, TRUE, TRUE);	
	
	lNTStatus = IoCallDriver(pDevTarget_Info->pAttachedDevObj, Irp);
	if (lNTStatus == STATUS_PENDING)
	{
		KeWaitForSingleObject(&tKEvent, Executive, KernelMode, FALSE, NULL);
	}

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	KdPrint(("FileterDriver Driver_Read is end.\n"));

	return STATUS_SUCCESS;
#else
	IoSetCompletionRoutine((PIRP)Irp, IoCompletionRoutine, NULL, TRUE, TRUE, TRUE);
	lNTStatus = IoCallDriver(pDevTarget_Info->pAttachedDevObj, Irp);

	KdPrint(("FileterDriver Driver_Read is end.\n"));

	return lNTStatus;
#endif // _TwiceIoComplete
}

NTSTATUS Driver_Close(_In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp)
{
	NTSTATUS lNTStatus = STATUS_SUCCESS;
	PDEVICETARGET_INFO pDevTarget_Info = (PDEVICETARGET_INFO)DeviceObject->DeviceExtension;

	KdPrint(("FileterDriver Driver_Close is enter.\n"));

	IoSkipCurrentIrpStackLocation(Irp);

	lNTStatus = IoCallDriver(pDevTarget_Info->pAttachedDevObj, Irp);

	KdPrint(("FileterDriver Driver_Close is end.\n"));

	return lNTStatus;
}
